--- ../src-base/minecraft/net/minecraft/block/BlockPistonBase.java
+++ ../src-work/minecraft/net/minecraft/block/BlockPistonBase.java
@@ -1,6 +1,8 @@
 package net.minecraft.block;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import java.util.AbstractList;
 import java.util.List;
 import javax.annotation.Nullable;
 import net.minecraft.block.material.EnumPushReaction;
@@ -28,6 +30,9 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
+import org.bukkit.craftbukkit.v1_12_R1.block.CraftBlock;
+import org.bukkit.event.block.BlockPistonExtendEvent;
+import org.bukkit.event.block.BlockPistonRetractEvent;
 
 public class BlockPistonBase extends BlockDirectional
 {
@@ -142,6 +147,15 @@
         }
         else if (!flag && ((Boolean)state.getValue(EXTENDED)).booleanValue())
         {
+            if (!this.isSticky) {
+                org.bukkit.block.Block block = worldIn.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
+                BlockPistonRetractEvent event = new BlockPistonRetractEvent(block, ImmutableList.<org.bukkit.block.Block>of(), CraftBlock.notchToBlockFace(enumfacing));
+                worldIn.getServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return;
+                }
+            }
             worldIn.addBlockEvent(pos, this, 1, enumfacing.getIndex());
         }
     }
@@ -241,7 +255,8 @@
                     }
                 }
 
-                if (!flag1 && iblockstate.getMaterial() != Material.AIR && canPush(iblockstate, worldIn, blockpos, enumfacing.getOpposite(), false, enumfacing) && (iblockstate.getMobilityFlag() == EnumPushReaction.NORMAL || block == Blocks.PISTON || block == Blocks.STICKY_PISTON))
+                // CraftBukkit - remove '!iblockstate.getBlock().isAir(iblockstate, worldIn, blockpos)' condition
+                if (!flag1 && canPush(iblockstate, worldIn, blockpos, enumfacing.getOpposite(), false, enumfacing) && (iblockstate.getMobilityFlag() == EnumPushReaction.NORMAL || block == Blocks.PISTON || block == Blocks.STICKY_PISTON))
                 {
                     this.doMove(worldIn, pos, enumfacing, false);
                 }
@@ -307,7 +322,7 @@
                     return false;
                 }
 
-                return !block.hasTileEntity();
+                return !block.hasTileEntity(blockStateIn);
             }
             else
             {
@@ -333,13 +348,11 @@
         {
             return false;
         }
-        else
-        {
+        else {
             List<BlockPos> list = blockpistonstructurehelper.getBlocksToMove();
             List<IBlockState> list1 = Lists.<IBlockState>newArrayList();
 
-            for (int i = 0; i < list.size(); ++i)
-            {
+            for (int i = 0; i < list.size(); ++i) {
                 BlockPos blockpos = list.get(i);
                 list1.add(worldIn.getBlockState(blockpos).getActualState(worldIn, blockpos));
             }
@@ -349,24 +362,101 @@
             IBlockState[] aiblockstate = new IBlockState[k];
             EnumFacing enumfacing = extending ? direction : direction.getOpposite();
 
-            for (int j = list2.size() - 1; j >= 0; --j)
-            {
+            final org.bukkit.block.Block bblock = worldIn.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
+
+            final List<BlockPos> moved = blockpistonstructurehelper.getBlocksToMove();
+            final List<BlockPos> broken = blockpistonstructurehelper.getBlocksToDestroy();
+
+            List<org.bukkit.block.Block> blocks = new AbstractList<org.bukkit.block.Block>() {
+
+                @Override
+                public int size() {
+                    return moved.size() + broken.size();
+                }
+
+                @Override
+                public org.bukkit.block.Block get(int index) {
+                    if (index >= size() || index < 0) {
+                        throw new ArrayIndexOutOfBoundsException(index);
+                    }
+                    BlockPos pos = index < moved.size() ? moved.get(index) : broken.get(index - moved.size());
+                    return bblock.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
+                }
+            };
+            boolean cancell = false;
+            for (BlockPos blockPos : moved) {
+                if (worldIn.getTileEntity(blockPos) != null) {
+                    cancell = true;
+                    break;
+                }
+            }
+            for (BlockPos blockPos : broken) {
+                if (worldIn.getTileEntity(blockPos) != null) {
+                    cancell = true;
+                    break;
+                }
+            }
+            if (cancell) {
+                for (BlockPos b : broken) {
+                    worldIn.notifyBlockUpdate(b, Blocks.AIR.getDefaultState(), worldIn.getBlockState(b), 3);
+                }
+                for (BlockPos b : moved) {
+                    worldIn.notifyBlockUpdate(b, Blocks.AIR.getDefaultState(), worldIn.getBlockState(b), 3);
+                    b = b.offset(enumfacing);
+                    worldIn.notifyBlockUpdate(b, Blocks.AIR.getDefaultState(), worldIn.getBlockState(b), 3);
+                }
+                return false;
+            }
+            org.bukkit.event.block.BlockPistonEvent event;
+            if (extending) {
+                event = new BlockPistonExtendEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumfacing));
+            } else {
+                event = new BlockPistonRetractEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumfacing));
+            }
+            worldIn.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                for (BlockPos b : broken) {
+                    worldIn.notifyBlockUpdate(b, Blocks.AIR.getDefaultState(), worldIn.getBlockState(b), 3);
+                }
+                for (BlockPos b : moved) {
+                    worldIn.notifyBlockUpdate(b, Blocks.AIR.getDefaultState(), worldIn.getBlockState(b), 3);
+                    b = b.offset(enumfacing);
+                    worldIn.notifyBlockUpdate(b, Blocks.AIR.getDefaultState(), worldIn.getBlockState(b), 3);
+                }
+                return false;
+            }
+
+            for (int j = list2.size() - 1; j >= 0; --j) {
                 BlockPos blockpos1 = list2.get(j);
                 IBlockState iblockstate = worldIn.getBlockState(blockpos1);
-                iblockstate.getBlock().dropBlockAsItem(worldIn, blockpos1, iblockstate, 0);
+                // Forge: With our change to how snowballs are dropped this needs to disallow to mimic vanilla behavior.
+                float chance = iblockstate.getBlock() instanceof BlockSnow ? -1.0f : 1.0f;
+                iblockstate.getBlock().dropBlockAsItemWithChance(worldIn, blockpos1, iblockstate, chance, 0);
                 worldIn.setBlockState(blockpos1, Blocks.AIR.getDefaultState(), 4);
                 --k;
                 aiblockstate[k] = iblockstate;
             }
 
-            for (int l = list.size() - 1; l >= 0; --l)
-            {
+            for (int l = list.size() - 1; l >= 0; --l) {
                 BlockPos blockpos3 = list.get(l);
                 IBlockState iblockstate2 = worldIn.getBlockState(blockpos3);
+                // Paper start - fix a variety of piston desync dupes
+                boolean allowDesync = com.destroystokyo.paper.PaperMCConfig.allowPistonDuplication;
+                BlockPos oldPos = blockpos3 = (BlockPos) list.get(k);
+                iblockstate2 = allowDesync ? worldIn.getBlockState(oldPos) : null;
+                // Paper end - fix a variety of piston desync dupes
                 worldIn.setBlockState(blockpos3, Blocks.AIR.getDefaultState(), 2);
                 blockpos3 = blockpos3.offset(enumfacing);
                 worldIn.setBlockState(blockpos3, Blocks.PISTON_EXTENSION.getDefaultState().withProperty(FACING, direction), 4);
+                // Paper start - fix a variety of piston desync dupes
+                if (!allowDesync) {
+                    iblockstate2 = worldIn.getBlockState(oldPos);
+                }
                 worldIn.setTileEntity(blockpos3, BlockPistonMoving.createTilePiston(list1.get(l), direction, extending, false));
+                if (!allowDesync) {
+                    worldIn.setBlockState(oldPos, Blocks.AIR.getDefaultState(), 4 | 16 | 1024); // set air to prevent later physics updates from seeing this block
+                }
                 --k;
                 aiblockstate[k] = iblockstate2;
             }
@@ -434,6 +524,13 @@
         return new BlockStateContainer(this, new IProperty[] {FACING, EXTENDED});
     }
 
+    /* ======================================== FORGE START =====================================*/
+    public boolean rotateBlock(World world, BlockPos pos, EnumFacing axis)
+    {
+        IBlockState state = world.getBlockState(pos);
+        return !state.getValue(EXTENDED) && super.rotateBlock(world, pos, axis);
+    }
+
     public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, IBlockState state, BlockPos pos, EnumFacing face)
     {
         state = this.getActualState(state, worldIn, pos);
